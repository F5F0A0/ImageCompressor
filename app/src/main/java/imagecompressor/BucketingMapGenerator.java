package imagecompressor;

import java.util.HashMap;
import java.util.Map;


class BucketingMapGenerator implements ColorMapGenerator_Inter {
    // The color map in this implementation will be based on partitioning the color space into evenly-sized buckets.
    // Specifically, consider the combined color (RGB) as a single 24-bit integer.
    // Let the red value constitute the most significant 8 bits.
    // Let the green value constitute the middle 8 bits.
    // Let the blue value constitute the least significant 8 bits.
    // Then, partition this range of values (from 0 to 2^24 - 1) evenly.

    // For instance, if 256 colors are desired, we note that 2^24/256 = 65536.
    // This means the ith bucket (starting with i = 0) begins at color value 65536 * i.
    // Thus, the first bucket contains any colors between 0 and 65535.
    // The next contains colors between 65535 and 131071, and so on,
    // with the final bucket containing colors between 16711680 and 16777215.

    // the mapping, then, maps each original color to the color in the center of the bucket
    // using the above 256-bucket example, any color in the first bucket would be mapped to 32768,
    // any color in the second bucket would be mapped to 98304, and so on
    // In general, the center of the ith bucket is 65536 * i + 32768

    /**
     * Produces an initial palette. For bucketing implementations, the initial
     * palette will be the centers of the evenly-divided buckets. For clustering
     * implementations, the initial palette will be the initial centroids. When
     * needed, a distance metric should be specified when the color map
     * generator is constructed.
     *
     * @param pixelArray the 2D Pixel array that represents a bitmap image
     * @param numColors the number of desired colors in the palette
     * @return a Pixel array containing numColors elements
     */
    @Override
    public Pixel[] generateColorPalette(Pixel[][] pixelArray, int numColors) {
        double bucketSize = 16777216.0/numColors; // gives us the bucket size which is 2^24/numColors
        double middleOfBucket = bucketSize/2.0; // gives us the middle of a bucket

        Pixel[] palette = new Pixel[numColors];

        for (int i = 0; i < numColors; i++) {
            double center = bucketSize * i + middleOfBucket; // center will be an integer color
            int finalCenter = (int) center;
            // how do we know what color this integer represents
            // do we convert the integer to binary?
            // no we don't
            // we need red/green/blue in int, so how do we get this
            // Consider the combined color (with red, green, and blue values) as a single 24-bit integer.
            // Let the red value constitute the most significant 8 bits, green middle, blue last

            int red = (finalCenter >> 16) & 0xFF; // red is the most significant 8 bits
            int green = (finalCenter >> 8) & 0xFF; // green is the middle 8 bits
            int blue = finalCenter & 0xFF; // blue is the least significant 8 bits
            Pixel newColor = new Pixel(red, green, blue);
            palette[i] = newColor;

            // how to convert a single 24-bit integer into it's separate bits
            // we know it can represent values between 0 and 2^24 - 1
            // each integer we come across we know is 24 bits, so we 0 extend?
            // 0 and 16777215
        }
        return palette;
    }

    /**
     * Computes the reduced color map. For bucketing implementations, this will
     * map each color to the center of its bucket. For clustering
     * implementations, this will map each color to its final centroid. When
     * needed, a distance metric should be specified when the color map
     * generator is constructed.
     *
     * @param pixelArray the pixels array that represents a bitmap image
     * @param initialColorPalette an initial color palette, such as those
     * generated by generateColorPalette, represented as an array of Pixels
     * @return A Map that maps each distinct color in pixelArray to a final
     * color
     */
    @Override
    public Map<Pixel, Pixel> generateColorMap(Pixel[][] pixelArray, Pixel[] initialColorPalette) {
        Map<Pixel, Pixel> colorMap = new HashMap<>();

        int numColors = initialColorPalette.length;
        double bucketSize = 16777216.0 / numColors;
    
        for (int i = 0; i < pixelArray.length; i++) {
            for (int j = 0; j < pixelArray[0].length; j++) {
                Pixel currentPixel = pixelArray[i][j];
    
                int combinedColor = (currentPixel.getRed() << 16) | (currentPixel.getGreen() << 8) | currentPixel.getBlue();
                double preciseIndex = combinedColor / bucketSize;
                int bucketIndex = Math.min((int) Math.floor(preciseIndex), numColors - 1); // Changed to Math.floor
    
                colorMap.put(currentPixel, initialColorPalette[bucketIndex]);
            }
        }
    
        return colorMap;
    }
}